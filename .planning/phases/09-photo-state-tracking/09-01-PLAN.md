---
phase: 09-photo-state-tracking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/stadion-db.js
  - prepare-stadion-members.js
autonomous: true

must_haves:
  truths:
    - "SQLite schema includes person_image_date column for tracking"
    - "SQLite schema includes photo_state column with valid states"
    - "System detects when PersonImageDate appears (new photo)"
    - "System detects when PersonImageDate changes (updated photo)"
    - "System detects when PersonImageDate becomes NULL (removed photo)"
    - "Query functions retrieve members by photo state"
  artifacts:
    - path: "lib/stadion-db.js"
      provides: "Photo state schema and tracking functions"
      exports: ["getMembersByPhotoState", "updatePhotoState", "clearPhotoState"]
    - path: "prepare-stadion-members.js"
      provides: "PersonImageDate extraction from Sportlink data"
      contains: "person_image_date"
  key_links:
    - from: "prepare-stadion-members.js"
      to: "lib/stadion-db.js"
      via: "member.person_image_date passed to upsertMembers"
      pattern: "person_image_date.*PersonImageDate"
    - from: "lib/stadion-db.js upsertMembers"
      to: "stadion_members table"
      via: "ON CONFLICT state detection"
      pattern: "photo_state.*CASE.*WHEN"
---

<objective>
Add photo state tracking to the Stadion sync database, enabling the system to detect when member photos need downloading, uploading, or deletion.

Purpose: This is the foundation for photo sync - without state tracking, we cannot know which photos have changed, been added, or removed in Sportlink.

Output: Extended SQLite schema with photo columns, state detection logic in upsertMembers, and query functions for downstream phases to retrieve members by photo state.
</objective>

<execution_context>
@/Users/joostdevalk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/joostdevalk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-photo-state-tracking/09-CONTEXT.md
@.planning/phases/09-photo-state-tracking/09-RESEARCH.md
@lib/stadion-db.js
@prepare-stadion-members.js
@field-mapping.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Photo State Tracking to stadion-db.js</name>
  <files>lib/stadion-db.js</files>
  <action>
Extend the stadion_members table with photo tracking columns and add state management functions.

**Schema extension in initDb():**

After the existing table creation, add PRAGMA-based column addition (following existing pattern on line 69-73 of laposta-db.js):

```javascript
const memberColumns = db.prepare('PRAGMA table_info(stadion_members)').all();

if (!memberColumns.some(col => col.name === 'person_image_date')) {
  db.exec('ALTER TABLE stadion_members ADD COLUMN person_image_date TEXT');
}

if (!memberColumns.some(col => col.name === 'photo_state')) {
  db.exec(`ALTER TABLE stadion_members ADD COLUMN photo_state TEXT DEFAULT 'no_photo' CHECK(photo_state IN ('no_photo', 'pending_download', 'downloaded', 'pending_upload', 'synced', 'pending_delete'))`);
}

if (!memberColumns.some(col => col.name === 'photo_state_updated_at')) {
  db.exec('ALTER TABLE stadion_members ADD COLUMN photo_state_updated_at TEXT');
}
```

**Modify upsertMembers() to handle photo state:**

Update the INSERT statement to include person_image_date, and add state detection logic in the ON CONFLICT clause:

```javascript
function upsertMembers(db, members) {
  const now = new Date().toISOString();
  const stmt = db.prepare(`
    INSERT INTO stadion_members (
      knvb_id,
      email,
      data_json,
      source_hash,
      last_seen_at,
      created_at,
      person_image_date,
      photo_state,
      photo_state_updated_at
    )
    VALUES (
      @knvb_id,
      @email,
      @data_json,
      @source_hash,
      @last_seen_at,
      @created_at,
      @person_image_date,
      CASE WHEN @person_image_date IS NOT NULL THEN 'pending_download' ELSE 'no_photo' END,
      @photo_state_updated_at
    )
    ON CONFLICT(knvb_id) DO UPDATE SET
      email = excluded.email,
      data_json = excluded.data_json,
      source_hash = excluded.source_hash,
      last_seen_at = excluded.last_seen_at,
      person_image_date = excluded.person_image_date,
      photo_state = CASE
        -- Photo added or changed: trigger download
        WHEN excluded.person_image_date IS NOT NULL
             AND (stadion_members.person_image_date IS NULL
                  OR excluded.person_image_date != stadion_members.person_image_date)
          THEN 'pending_download'
        -- Photo removed: trigger deletion
        WHEN excluded.person_image_date IS NULL
             AND stadion_members.person_image_date IS NOT NULL
          THEN 'pending_delete'
        -- No change: keep current state
        ELSE stadion_members.photo_state
      END,
      photo_state_updated_at = CASE
        WHEN excluded.person_image_date IS NOT NULL
             AND (stadion_members.person_image_date IS NULL
                  OR excluded.person_image_date != stadion_members.person_image_date)
          THEN excluded.photo_state_updated_at
        WHEN excluded.person_image_date IS NULL
             AND stadion_members.person_image_date IS NOT NULL
          THEN excluded.photo_state_updated_at
        ELSE stadion_members.photo_state_updated_at
      END
  `);

  // Update rows mapping to include photo fields
  const rows = members.map((member) => {
    const data = member.data || {};
    return {
      knvb_id: member.knvb_id,
      email: member.email || null,
      data_json: stableStringify(data),
      source_hash: computeSourceHash(member.knvb_id, data),
      last_seen_at: now,
      created_at: now,
      person_image_date: member.person_image_date || null,
      photo_state_updated_at: now
    };
  });

  // Rest of function unchanged...
}
```

**Add new query functions:**

```javascript
/**
 * Get members by photo state (for photo sync operations)
 * @param {Object} db - SQLite database connection
 * @param {string} state - Photo state to filter by
 * @returns {Array<{knvb_id: string, email: string, person_image_date: string, stadion_id: number}>}
 */
function getMembersByPhotoState(db, state) {
  const stmt = db.prepare(`
    SELECT knvb_id, email, person_image_date, stadion_id
    FROM stadion_members
    WHERE photo_state = ?
    ORDER BY knvb_id ASC
  `);
  return stmt.all(state);
}

/**
 * Update photo state after download/upload/delete operations
 * @param {Object} db - SQLite database connection
 * @param {string} knvbId - Member KNVB ID
 * @param {string} newState - New photo state
 */
function updatePhotoState(db, knvbId, newState) {
  const now = new Date().toISOString();
  const stmt = db.prepare(`
    UPDATE stadion_members
    SET photo_state = ?, photo_state_updated_at = ?
    WHERE knvb_id = ?
  `);
  stmt.run(newState, now, knvbId);
}

/**
 * Clear photo state to no_photo (after successful deletion)
 * Also clears person_image_date to prevent re-triggering
 * @param {Object} db - SQLite database connection
 * @param {string} knvbId - Member KNVB ID
 */
function clearPhotoState(db, knvbId) {
  const now = new Date().toISOString();
  const stmt = db.prepare(`
    UPDATE stadion_members
    SET photo_state = 'no_photo', person_image_date = NULL, photo_state_updated_at = ?
    WHERE knvb_id = ?
  `);
  stmt.run(now, knvbId);
}
```

**Export the new functions:**

Add to module.exports: getMembersByPhotoState, updatePhotoState, clearPhotoState
  </action>
  <verify>
Run: `node -e "const db = require('./lib/stadion-db'); const d = db.openDb(); console.log(d.prepare('PRAGMA table_info(stadion_members)').all().map(c => c.name).join(', ')); d.close()"`

Expected output should include: person_image_date, photo_state, photo_state_updated_at

Run: `node -e "const db = require('./lib/stadion-db'); console.log(typeof db.getMembersByPhotoState, typeof db.updatePhotoState, typeof db.clearPhotoState)"`

Expected: function function function
  </verify>
  <done>
- stadion_members table has person_image_date, photo_state, and photo_state_updated_at columns
- photo_state has CHECK constraint limiting to valid states
- upsertMembers detects photo changes and sets appropriate state
- getMembersByPhotoState returns members filtered by state
- updatePhotoState and clearPhotoState modify state correctly
  </done>
</task>

<task type="auto">
  <name>Task 2: Pass PersonImageDate Through Pipeline</name>
  <files>prepare-stadion-members.js</files>
  <action>
Update the member preparation to extract and pass PersonImageDate from Sportlink data.

**In preparePerson() function:**

The PersonImageDate field is available in Sportlink data (mapped from `datumpasfoto` in field-mapping.json). Add it to the returned member object.

Update the return statement (around line 106-113) to include person_image_date:

```javascript
function preparePerson(sportlinkMember) {
  const name = buildName(sportlinkMember);
  const gender = mapGender(sportlinkMember.GenderCode);
  const birthYear = extractBirthYear(sportlinkMember.DateOfBirth);

  const acf = {
    first_name: name.first_name,
    last_name: name.last_name,
    knvb_id: sportlinkMember.PublicPersonId,
    contact_info: buildContactInfo(sportlinkMember),
    addresses: buildAddresses(sportlinkMember)
  };

  // Only add optional fields if they have values
  if (gender) acf.gender = gender;
  if (birthYear) acf.birth_year = birthYear;

  // Extract PersonImageDate for photo state tracking
  // Normalize to null if empty string or whitespace
  const personImageDate = (sportlinkMember.PersonImageDate || '').trim() || null;

  return {
    knvb_id: sportlinkMember.PublicPersonId,
    email: (sportlinkMember.Email || '').trim().toLowerCase() || null,
    person_image_date: personImageDate,
    data: {
      status: 'publish',
      acf: acf
    }
  };
}
```

Note: Empty string is normalized to null so SQL comparisons work correctly (NULL IS NULL, not '' = NULL).
  </action>
  <verify>
Run: `node -e "const { runPrepare } = require('./prepare-stadion-members'); runPrepare({ verbose: false }).then(r => { if (r.members.length > 0) { const m = r.members[0]; console.log('Has person_image_date key:', 'person_image_date' in m); console.log('Sample value:', m.person_image_date); } else { console.log('No members to check'); } })"`

Expected: Has person_image_date key: true (value will be date string or null depending on member data)
  </verify>
  <done>
- preparePerson extracts PersonImageDate from Sportlink data
- Empty strings normalized to null for correct SQL NULL handling
- person_image_date included in member object passed to upsertMembers
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Schema verification:**
   ```bash
   node -e "
   const db = require('./lib/stadion-db');
   const d = db.openDb();
   const cols = d.prepare('PRAGMA table_info(stadion_members)').all();
   console.log('Photo columns present:');
   console.log('  person_image_date:', cols.some(c => c.name === 'person_image_date'));
   console.log('  photo_state:', cols.some(c => c.name === 'photo_state'));
   console.log('  photo_state_updated_at:', cols.some(c => c.name === 'photo_state_updated_at'));
   d.close();
   "
   ```

2. **Function exports verification:**
   ```bash
   node -e "
   const db = require('./lib/stadion-db');
   console.log('New functions exported:');
   console.log('  getMembersByPhotoState:', typeof db.getMembersByPhotoState === 'function');
   console.log('  updatePhotoState:', typeof db.updatePhotoState === 'function');
   console.log('  clearPhotoState:', typeof db.clearPhotoState === 'function');
   "
   ```

3. **Integration test (requires existing data):**
   ```bash
   node -e "
   const { runPrepare } = require('./prepare-stadion-members');
   runPrepare({ verbose: false }).then(r => {
     const withPhoto = r.members.filter(m => m.person_image_date);
     const withoutPhoto = r.members.filter(m => !m.person_image_date);
     console.log('Members with PersonImageDate:', withPhoto.length);
     console.log('Members without PersonImageDate:', withoutPhoto.length);
   });
   "
   ```
</verification>

<success_criteria>
- [ ] stadion_members table has person_image_date TEXT column
- [ ] stadion_members table has photo_state TEXT column with CHECK constraint
- [ ] stadion_members table has photo_state_updated_at TEXT column
- [ ] upsertMembers accepts person_image_date and detects state changes
- [ ] New photo (PersonImageDate appears) -> photo_state = 'pending_download'
- [ ] Changed photo (PersonImageDate changes) -> photo_state = 'pending_download'
- [ ] Removed photo (PersonImageDate becomes NULL) -> photo_state = 'pending_delete'
- [ ] getMembersByPhotoState returns members filtered by state
- [ ] updatePhotoState modifies state and timestamp
- [ ] clearPhotoState resets to no_photo and clears person_image_date
- [ ] prepare-stadion-members.js passes person_image_date to member objects
</success_criteria>

<output>
After completion, create `.planning/phases/09-photo-state-tracking/09-01-SUMMARY.md`
</output>
