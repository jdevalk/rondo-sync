---
phase: 17-memberheader-data-capture
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/stadion-db.js
  - download-functions-from-sportlink.js
autonomous: true

must_haves:
  truths:
    - "MemberHeader API response is captured during /other page visit"
    - "Financial block boolean (HasFinancialTransferBlockOwnClub) is extracted and stored per member"
    - "Photo URL and PhotoDate are extracted (handling null Photo object gracefully)"
    - "Data persists in SQLite sportlink_member_free_fields table"
  artifacts:
    - path: "lib/stadion-db.js"
      provides: "Schema migration for new columns and updated upsert"
      contains: "has_financial_block"
    - path: "download-functions-from-sportlink.js"
      provides: "Parallel MemberHeader API capture"
      contains: "MemberHeader"
  key_links:
    - from: "download-functions-from-sportlink.js"
      to: "/member/MemberHeader"
      via: "page.waitForResponse"
      pattern: "waitForResponse.*MemberHeader"
    - from: "download-functions-from-sportlink.js"
      to: "lib/stadion-db.js"
      via: "upsertMemberFreeFields call"
      pattern: "upsertMemberFreeFields.*has_financial_block"
---

<objective>
Capture MemberHeader API response during existing /other page visit and extract financial block status and photo metadata for downstream sync phases.

Purpose: Phase 17 is the data capture foundation for v1.7 MemberHeader API milestone. It enables Phase 18 (financial block sync to Stadion) and Phase 19 (photo API optimization) by capturing and storing the required data from Sportlink's MemberHeader API response.

Output:
- SQLite schema with new columns (has_financial_block, photo_url, photo_date)
- Data extraction code that captures MemberHeader alongside existing MemberFreeFields
- Stored data for all members with functions/committees
</objective>

<execution_context>
@/Users/joostdevalk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/joostdevalk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md

# Source files to modify
@lib/stadion-db.js
@download-functions-from-sportlink.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add schema migration and update upsert for MemberHeader fields</name>
  <files>lib/stadion-db.js</files>
  <action>
Add three new columns to the `sportlink_member_free_fields` table via conditional migration in `initDb()`:

1. In `initDb()`, after the existing table creation, add conditional column additions using the established PRAGMA pattern:

```javascript
// Add MemberHeader columns to sportlink_member_free_fields if they don't exist
const freeFieldColumns = db.prepare('PRAGMA table_info(sportlink_member_free_fields)').all();

if (!freeFieldColumns.some(col => col.name === 'has_financial_block')) {
  db.exec('ALTER TABLE sportlink_member_free_fields ADD COLUMN has_financial_block INTEGER DEFAULT 0');
}

if (!freeFieldColumns.some(col => col.name === 'photo_url')) {
  db.exec('ALTER TABLE sportlink_member_free_fields ADD COLUMN photo_url TEXT');
}

if (!freeFieldColumns.some(col => col.name === 'photo_date')) {
  db.exec('ALTER TABLE sportlink_member_free_fields ADD COLUMN photo_date TEXT');
}
```

2. Update `computeMemberFreeFieldsHash()` to include the new fields:

```javascript
function computeMemberFreeFieldsHash(knvbId, freescoutId, vogDatum, hasFinancialBlock, photoUrl, photoDate) {
  const payload = stableStringify({
    knvb_id: knvbId,
    freescout_id: freescoutId,
    vog_datum: vogDatum,
    has_financial_block: hasFinancialBlock,
    photo_url: photoUrl,
    photo_date: photoDate
  });
  return crypto.createHash('sha256').update(payload).digest('hex');
}
```

3. Update `upsertMemberFreeFields()` to handle new columns in the INSERT and ON CONFLICT statements:

- Add `has_financial_block`, `photo_url`, `photo_date` to both column list and VALUES
- Add them to the ON CONFLICT DO UPDATE SET clause
- Update the row mapping to include new fields with proper defaults (null for optional, 0 for has_financial_block if undefined)

4. Update the module.exports to export the updated function signature.

IMPORTANT: Use INTEGER for has_financial_block (SQLite has no native boolean), store as 0/1. Use TEXT for photo_url and photo_date.
  </action>
  <verify>
Run: `node -e "const db = require('./lib/stadion-db'); const d = db.openDb(); const cols = d.prepare('PRAGMA table_info(sportlink_member_free_fields)').all(); console.log(cols.map(c => c.name)); d.close()"`

Expected output should include: has_financial_block, photo_url, photo_date
  </verify>
  <done>
- sportlink_member_free_fields table has columns: has_financial_block (INTEGER), photo_url (TEXT), photo_date (TEXT)
- computeMemberFreeFieldsHash includes all 6 fields in hash computation
- upsertMemberFreeFields accepts and stores records with new fields
  </done>
</task>

<task type="auto">
  <name>Task 2: Capture MemberHeader API response in parallel with MemberFreeFields</name>
  <files>download-functions-from-sportlink.js</files>
  <action>
Modify `fetchMemberFreeFields()` function to capture MemberHeader API response in parallel:

1. Rename function to `fetchMemberDataFromOtherPage()` to reflect its expanded purpose (captures both FreeFields and MemberHeader)

2. Add parallel waitForResponse for MemberHeader:

```javascript
// Set up promises BEFORE navigation (existing pattern)
const freeFieldsPromise = page.waitForResponse(
  resp => resp.url().includes('/remarks/MemberFreeFields?'),
  { timeout: 15000 }
).catch(() => null);

// NEW: Add MemberHeader promise in parallel
const memberHeaderPromise = page.waitForResponse(
  resp => resp.url().includes('/member/MemberHeader?'),
  { timeout: 15000 }
).catch(() => null);

// Navigate (existing)
await page.goto(otherUrl, { waitUntil: 'networkidle' });

// Await both responses
const [freeFieldsResponse, memberHeaderResponse] = await Promise.all([
  freeFieldsPromise,
  memberHeaderPromise
]);
```

3. Parse MemberHeader response (add after existing freeFields parsing):

```javascript
let memberHeaderData = null;
if (memberHeaderResponse && memberHeaderResponse.ok()) {
  try {
    memberHeaderData = await memberHeaderResponse.json();
  } catch (err) {
    logger.verbose(`  Error parsing MemberHeader: ${err.message}`);
  }
}
```

4. Create parser function `parseMemberHeaderResponse()`:

```javascript
function parseMemberHeaderResponse(data, knvbId) {
  // Handle null/missing Photo object gracefully
  const photoUrl = data?.Photo?.Url || null;
  const photoDate = data?.Photo?.PhotoDate || null;

  // Boolean to integer for SQLite (true -> 1, false/null -> 0)
  const hasFinancialBlock = data?.HasFinancialTransferBlockOwnClub === true ? 1 : 0;

  return {
    has_financial_block: hasFinancialBlock,
    photo_url: photoUrl,
    photo_date: photoDate
  };
}
```

5. Merge data in the return statement - combine FreeFields data with MemberHeader data:

```javascript
// Inside the function, merge both data sources
const freeFieldsResult = parseFreeFieldsResponse(freeFieldsData, knvbId);
const memberHeaderResult = memberHeaderData ? parseMemberHeaderResponse(memberHeaderData, knvbId) : { has_financial_block: 0, photo_url: null, photo_date: null };

return {
  knvb_id: knvbId,
  freescout_id: freeFieldsResult.freescout_id,
  vog_datum: freeFieldsResult.vog_datum,
  has_financial_block: memberHeaderResult.has_financial_block,
  photo_url: memberHeaderResult.photo_url,
  photo_date: memberHeaderResult.photo_date
};
```

6. Update the caller in `runFunctionsDownload()` to pass the new fields to `upsertMemberFreeFields()`:

The existing code pushes to `allFreeFields` array - ensure the objects now include the new fields.

7. Add verbose logging for the new fields captured:

```javascript
logger.verbose(`  Financial block: ${memberHeaderResult.has_financial_block}, Photo: ${memberHeaderResult.photo_url ? 'yes' : 'no'}`);
```

IMPORTANT:
- Include the `?` in URL pattern: `/member/MemberHeader?` to avoid matching wrong endpoints
- Set up waitForResponse promises BEFORE page.goto() to avoid race conditions
- Use optional chaining (`?.`) for all Photo property access since Photo can be null
  </action>
  <verify>
Run with DEBUG_LOG=true on the server to verify MemberHeader capture:

```bash
ssh root@46.202.155.16 "cd /home/sportlink && DEBUG_LOG=true node download-functions-from-sportlink.js --verbose 2>&1 | head -100"
```

Look for:
1. Request/response logs showing `/member/MemberHeader?` being captured
2. Verbose output showing "Financial block: X, Photo: yes/no" lines

Also verify database storage:

```bash
ssh root@46.202.155.16 "cd /home/sportlink && sqlite3 rondo-sync.sqlite 'SELECT knvb_id, has_financial_block, photo_url, photo_date FROM sportlink_member_free_fields LIMIT 5;'"
```
  </verify>
  <done>
- MemberHeader API response is captured in parallel with MemberFreeFields during /other page visit
- HasFinancialTransferBlockOwnClub is extracted as integer (0/1)
- Photo.Url and Photo.PhotoDate are extracted (null when Photo object missing)
- All captured data is stored in sportlink_member_free_fields table
- Verbose logging shows financial block and photo status for each member processed
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. Schema verification:
```bash
node -e "const db = require('./lib/stadion-db'); const d = db.openDb(); console.log(d.prepare('PRAGMA table_info(sportlink_member_free_fields)').all().map(c => c.name + ':' + c.type)); d.close()"
```
Expected: includes has_financial_block:INTEGER, photo_url:TEXT, photo_date:TEXT

2. Data capture verification (on server):
```bash
ssh root@46.202.155.16 "cd /home/sportlink && node download-functions-from-sportlink.js --verbose 2>&1 | tail -20"
```
Should show "Free fields (VOG/FreeScout)" count > 0 and member processing with financial block status

3. Database content verification:
```bash
ssh root@46.202.155.16 "cd /home/sportlink && sqlite3 rondo-sync.sqlite 'SELECT COUNT(*) as total, SUM(has_financial_block) as with_block, SUM(CASE WHEN photo_url IS NOT NULL THEN 1 ELSE 0 END) as with_photo FROM sportlink_member_free_fields;'"
```
Should show reasonable counts for members with financial blocks and photos
</verification>

<success_criteria>
- [ ] `sportlink_member_free_fields` table has three new columns: `has_financial_block` (INTEGER), `photo_url` (TEXT), `photo_date` (TEXT)
- [ ] MemberHeader API response is captured during `/other` page visit without additional page loads
- [ ] Financial block status is extracted as 0/1 integer for each member
- [ ] Photo URL and date are extracted (null for members without photos)
- [ ] Data is stored in SQLite via `upsertMemberFreeFields()`
- [ ] Hash computation includes new fields for change detection
- [ ] No errors when Photo object is null/missing
</success_criteria>

<output>
After completion, create `.planning/phases/17-memberheader-data-capture/17-01-SUMMARY.md`
</output>
